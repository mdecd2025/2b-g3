var tipuesearch = {"pages": [{'title': 'About', 'text': '課程名稱: 協同產品設計實習 - Collaborative Product Design Practice \n 2b\xa0 g3第幾組網站:\xa0 https://mdecd2025.github.io/2b-g3 \n 2b\xa0 g3第幾組倉儲:\xa0 https://github.com/mdecd2025/2b-g3 \n \n 課程代號: cd2025 \n Teams 線上教學: \n 以 "學號@nfu.edu.tw" 登入 \xa0 https://login.microsoftonline.com/ \xa0 Office 365 \n Teams 團隊代碼:\xa0 p5z4eku \n \n 課程評分: \n Homework (30%) - 每週至少提交兩次與課程進度有關的內容, 完成後填回自評表單 \n Exam (40%) - 建立包含操作流程影片、心得以及提供檔案下載的網頁後填回自評表單 \n Final Report (30%) - 利用網頁內容進行簡報並提交 pdf 格式書面報告, 完成後填回自評表單 \n', 'tags': '', 'url': 'About.html'}, {'title': 'repo', 'text': '在更新小組list的程式時，順便做的。( 執行結果 ) \n from browser import html, document\nimport urllib.request\n\n# 設定 URL\nurl = "https://mde.tw/list/2b.txt"\n\n# 讀取網站內容\nresponse = urllib.request.urlopen(url)\ndata = response.read().splitlines()  # 直接讀取並按行分割\n\n# 確保資料存在\nif len(data) > 1:\n    all_stud = data[1:]  # 跳過標題列\n    print("總共有 " + str(len(all_stud)) + " 名學員")\nelse:\n    all_stud = []\n    print("學員名單讀取失敗")\n\n# 找到網頁中的特定位置\nbrython_div1 = document["brython_div1"]\n\n# **動態插入所有學員資料，並為帳號添加超連結**\nfor index, student in enumerate(all_stud, start=1):\n    parts = student.split()  # 用空格分割學號和帳號\n    if len(parts) == 2:\n        student_id, account = parts\n        # 設定學號的超連結\n        account_link = f"https://mdecd2025.github.io/hw-{account.strip()}"\n        # 設定repo的超連結\n        repo_link = f"https://github.com/mdecd2025/hw-{account.strip()}"\n        \n        # 插入學號和帳號的超連結，並加上repo的超連結\n        brython_div1 <= f"{index}. " + html.A(student_id.strip(), href=account_link) + " " \n        brython_div1 <= f"（" + html.A("repo", href=repo_link) + "）"\n        brython_div1 <= html.BR()  # 換行\n    else:\n        print(f"格式錯誤，跳過此行: {student}")\n \n \n \n', 'tags': '', 'url': 'repo.html'}, {'title': 'Tasks', 'text': 'task1 與 task2 任務目的在建立可於近端維護個人作業與協同作業的準備工作: \n task1 (自行製作可攜程式系統) \n task2 (使用 SSH 協定執行作業倉儲的推送) \n task3 與 task4 則為 HW2 的內容之一 \n task3 (使用 Solvespace 建立平面四連桿系統零組件) \n task4 (使用 Onshape 建立平面四連桿系統零組件) \n task5 與 task6 則為 HW3 的主要內容 \n task5 (Webots Tutorial 1 ~3) \n task6 (Webots Tutorial 4 ~6) \n', 'tags': '', 'url': 'Tasks.html'}, {'title': 'task1', 'text': 'Portable\xa0 自行製作可攜程式系統 \n 目前最新的 Python 版本為 3.13.2, 利用舊版的 Python310,來建立 Python313可攜程式\xa0 \n (為了配合 Siemens NX2312)s \n \n', 'tags': '', 'url': 'task1.html'}, {'title': 'list', 'text': '\n g3成員 \n 查找g3成員的github頁面超鏈接和作業網站超鏈接 \n from browser import html, document, window\n\n# 定義資料來源 URL\nurl = "https://mde.tw/list/2b.txt"\n\n# 定義要查找的學號列表\ntarget_ids = ["41223226", "41223228", "41223206", "41223235", "41223227", "41223215"]\n\n# 顯示學員總數\nprint("正在處理學員資料...")\n\n# 取得 HTML 中的元素 id 為 "brython_div1"\nbrython_div1 = document["brython_div1"]\n\n# 使用 JavaScript 的 fetch API 來抓取資料\ndef process_data(response_text):\n    # 將抓取到的資料分行\n    data = response_text.splitlines()\n\n    # 跳過標題行，取得學員資料\n    all_stud = data[1:]\n\n    # 逐行處理學員資料\n    for stud in all_stud:\n        # 假設學員資料的格式為 "學號 學員賬號"\n        student_info = stud.strip().split()  # 使用 split() 將每行分為學號和帳號\n        if len(student_info) == 2:  # 確保每行有學號和帳號\n            student_id = student_info[0].strip()  # 學號\n            student_account = student_info[1].strip()  # 學員賬號\n\n            # 檢查學號是否在目標學號列表中\n            if student_id in target_ids:\n                # 創建 GitHub 和作業網站的超鏈接\n                github_link = f"https://github.com/mdecd2025/hw-{student_account}"\n                homework_link = f"https://mdecd2025.github.io/hw-{student_account}/"\n                \n                # 顯示該學號的 GitHub 和作業網站\n                brython_div1 <= html.A(student_id, href=github_link)  # 學號是 GitHub repo 連結\n                brython_div1 <= " "  # 空格\n                brython_div1 <= html.A("(repo)", href=homework_link)  # 作業網站的超鏈接標題為 (repo)\n                brython_div1 <= html.BR()  # 換行\n\n# 使用 JavaScript 的 fetch API 拉取資料\nwindow.fetch(url).then(lambda response: response.text()).then(process_data) \n 查找學員github超鏈接 \n from browser import html, document\n\n# 定義資料來源 URL\nurl = "https://mde.tw/list/2b.txt"\n\n# 讀取資料\ndata = open(url).readlines()\n\n# 跳過標題行，取得學員資料\nall_stud = data[1:]\n\n# 顯示學員總數\nprint("總共有 " + str(len(all_stud)) + "名學員")\n\n# 取得 HTML 中的元素 id 為 "brython_div1"\nbrython_div1 = document["brython_div1"]\n\n# 逐行處理學員資料\nfor stud in all_stud:\n    # 假設學員資料的格式為 "學號 學員賬號"\n    student_info = stud.strip().split()  # 使用 split() 將每行分為學號和帳號\n    if len(student_info) == 2:  # 確保每行有學號和帳號\n        student_id = student_info[0].strip()  # 學號\n        student_account = student_info[1].strip()  # 學員賬號\n\n        # 創建 GitHub 和作業網站的超鏈接\n        github_link = f"https://github.com/mdecd2025/hw-{student_account}"\n        homework_link = f"https://mdecd2025.github.io/hw-{student_account}/"\n        \n        # 將學號作為 GitHub repository 的鏈接\n        brython_div1 <= html.A(student_id, href=github_link)  # 學號是 GitHub repo 連結\n        brython_div1 <= " "  # 空格\n        \n        # 插入作業網站的超鏈接，標題改為 "(repo)"\n        brython_div1 <= html.A("(repo)", href=homework_link)  # 作業網站的超鏈接標題為 (repo)\n        \n        # 插入換行\n        brython_div1 <= html.BR()  # 換行 \n \n', 'tags': '', 'url': 'list.html'}, {'title': 'task2', 'text': '近端倉儲推送: \n https://youtu.be/8n1LiOqBkko \n \n https://youtu.be/1Y36Zis2M6E \n \n 建立SSH key: \n \n \n', 'tags': '', 'url': 'task2.html'}, {'title': 'w3', 'text': '列出目前尚未納入分組的學員名單. \n from browser import html, document, window\n\n# 資料來源\nurl = "https://mde.tw/list/2b.txt"\n\n# 已分組 GitHub 帳號清單\ngrouped_accounts = {\n    \'41223251\', \'41223211\', \'41223245\', \'41223243\', \'jjjay41223212\', \'leeshaowei0716\',\n    \'41223234\', \'41223209\', \'41223205\', \'41223201\', \'41223202\', \'41223208-hw\',\n    \'41223216\', \'41223217\', \'41223248\', \'emma0312\', \'41223242\', \'41223203\',\n    \'41223144\', \'41223235\', \'RAY41223215\', \'hyy41223228\', \'41223227\', \'41223206\',\n    \'41223226-0\', \'Cloud41223237\', \'Yujenchuang\', \'41223225\', \'ljg41223220\',\n    \'supowen\', \'jacky93111\', \'41223246\', \'Liu41223244\', \'41223236\', \'41223219\',\n    \'41271237\', \'41223249\', \'41223229\', \'41223224\', \'41223222\', \'41223231\',\n    \'linryan23\', \'41023114\', \'41223230\', \'timluo123\', \'CYC41223247\', \'41223218\',\n    \'ych0227\', \'41023215\', \'41023216\', \'41023213\', \'41071203\', \'41071204\',\n    \'41071202\', \'c-ching\', \'YUN4\', \'tseYU000\', \'snowfall-killer\', \'junpig10\'\n}\n\nbrython_div1 = document["brython_div1"]\n\ndef process_data(response_text):\n    data = response_text.splitlines()\n    all_stud = data[1:]\n\n    for stud in all_stud:\n        student_info = stud.strip().split()\n\n        if len(student_info) == 2:\n            student_id = student_info[0].strip()\n            student_account = student_info[1].strip()\n\n            # 帳號不在已分組名單 → 尚未分組\n            if student_account not in grouped_accounts:\n                brython_div1 <= student_id\n                brython_div1 <= html.BR()\n\n        elif len(student_info) == 1:\n            # 沒有帳號的直接列出\n            student_id = student_info[0].strip()\n            brython_div1 <= student_id\n            brython_div1 <= html.BR()\n\nwindow.fetch(url).then(lambda response: response.text()).then(process_data)\n \n \n', 'tags': '', 'url': 'w3.html'}, {'title': 'task3', 'text': '使用 Solvespace 建立平面四連桿系統零組件 \n Download.slvs \n link1 \n \\ \n link2 \n \n link3 \n \n base \n \n \n shaft \n \n shaft2 \n \n fourbar linkage design \n \n fourbar linkage design w assembly \n \n', 'tags': '', 'url': 'task3.html'}, {'title': 'task4', 'text': '', 'tags': '', 'url': 'task4.html'}, {'title': 'w4', 'text': '/downloads/41223228.zip 完成的檔案 \n 建造平面四連桿的尺寸設計: 固定桿長度為 1m, 主動旋轉桿長度為 0.4m, 第二旋轉桿長度為 0.6m, 第三旋轉桿長度為 0.9m \n 1.建立robot群組 \n 2.robot下的children建立1個solid群組，2個higejoint群組，並選一個為首要，命名為joint1 \n 3.solid的children中建立shape作為固定桿(X1,Y0.1,Z0.1) \n 4. joint1下的endpoint選擇solid性質，命名為link1，並往下的children中建立pose及higejoint，pose下在建立shape為主動桿(0.4,0.1,0.1) ，shape命名為link1，再將主動桿所屬的pose的translation設為(0.2,0,0)(此為link1中心點)，而higejoint為主動桿與第二桿連接，並命名為joint2。 \n 5.joint1的endpoint下有translation(此為連接處的座標點)，設(-0.5,0,0.1) \n 6.在joint1下有boundingObject，選擇pose，往下children選擇USE link1，並調整座標至(0.2,0,0)(與link1的pose座標一致)，在設置physics \n 7.以上順序重複製作，主要為base-->joint1-->link1--> joint2-->link2--> joint3-->link3-->joint4 \n 8.joint4在robot群組中的children，與joint1同排列，並將endpoint設為solidreference，並選為use link3 \n 9.每一階的joint中各有jointparameters、device、emdpoint，其中link1上的device要加入Rotationalmotor，並命名為motor \n 10.而每一階的jointparameters，axis設為(0,0,1)(意為繞z軸旋轉)，但anchor要設為桿的長度，這樣才是joint到joint的距離，分別為(-0.5,0,0)、(0.4,0,0)、(0.6,0,0)，此座標是接續的，原點根據base的起點，另外設置的joint4則為(0.5,0,0) \n \n', 'tags': '', 'url': 'w4.html'}, {'title': 'w6', 'text': 'hw2的連桿尺寸是曲柄40mm鏈接桿60mm搖桿90mm \n 組裝影片 \n /downloads/41223228 hw-2.7z \n \n 使用task3的零件組裝後導出stl檔，現在要把stl檔轉成 Webots\xa0可以使用的obj檔 \n #!/usr/bin/env python\n# -*- coding: utf-8 -*-\n"""\nCreated on: 2025-02-09 15:40:51 UTC\nAuthor: mdecycu\nDescription: STL file converter that splits STL files into multiple OBJ files with MTL materials\n"""\n\nimport struct\nimport numpy as np\nfrom pathlib import Path\n\nclass STLConverter:\n    def __init__(self, filename, scale=0.001):  # 新增 scale 參數，預設 0.001 將 mm 轉換為 m\n        self.filename = filename\n        self.scale = scale\n        self.is_binary = self._check_if_binary()\n        \n    def _check_if_binary(self):\n        """檢查 STL 檔案是否為二進制格式"""\n        with open(self.filename, \'rb\') as f:\n            header = f.read(5).decode(\'utf-8\', errors=\'ignore\')\n            return not header.startswith(\'solid\')\n    \n    def _read_binary_stl(self):\n        """讀取二進制 STL 檔案"""\n        with open(self.filename, \'rb\') as f:\n            f.seek(80)\n            triangle_count = struct.unpack(\'I\', f.read(4))[0]\n            \n            triangles = []\n            normals = []\n            \n            for _ in range(triangle_count):\n                nx, ny, nz = struct.unpack(\'fff\', f.read(12))\n                normals.append([nx, ny, nz])\n                \n                triangle = []\n                for _ in range(3):\n                    x, y, z = struct.unpack(\'fff\', f.read(12))\n                    # 在讀取頂點時進行縮放\n                    triangle.append([x * self.scale, y * self.scale, z * self.scale])\n                triangles.append(triangle)\n                \n                f.seek(2, 1)\n                \n        return np.array(triangles), np.array(normals)\n    \n    def _read_ascii_stl(self):\n        """讀取 ASCII STL 檔案"""\n        triangles = []\n        normals = []\n        current_triangle = []\n        \n        with open(self.filename, \'r\') as f:\n            for line in f:\n                line = line.strip()\n                if not line:\n                    continue\n                    \n                parts = line.split()\n                if not parts:\n                    continue\n                \n                if parts[0] == \'facet\' and parts[1] == \'normal\':\n                    normals.append([float(parts[2]), float(parts[3]), float(parts[4])])\n                elif parts[0] == \'vertex\':\n                    # 在讀取頂點時進行縮放\n                    current_triangle.append([\n                        float(parts[1]) * self.scale,\n                        float(parts[2]) * self.scale,\n                        float(parts[3]) * self.scale\n                    ])\n                elif parts[0] == \'endfacet\':\n                    if current_triangle:\n                        triangles.append(current_triangle)\n                        current_triangle = []\n        \n        return np.array(triangles), np.array(normals)\n    \n    def _split_by_connected_components(self, triangles, normals):\n        """使用連通分量分割模型"""\n        vertex_to_triangle = {}\n        for i, triangle in enumerate(triangles):\n            for vertex in triangle:\n                vertex_tuple = tuple(vertex)\n                if vertex_tuple in vertex_to_triangle:\n                    vertex_to_triangle[vertex_tuple].append(i)\n                else:\n                    vertex_to_triangle[vertex_tuple] = [i]\n        \n        visited = set()\n        components = []\n        \n        def dfs(triangle_idx):\n            component = []\n            stack = [triangle_idx]\n            \n            while stack:\n                current = stack.pop()\n                if current not in visited:\n                    visited.add(current)\n                    component.append(current)\n                    \n                    for vertex in triangles[current]:\n                        vertex_tuple = tuple(vertex)\n                        for neighbor in vertex_to_triangle[vertex_tuple]:\n                            if neighbor not in visited:\n                                stack.append(neighbor)\n            \n            return component\n        \n        for i in range(len(triangles)):\n            if i not in visited:\n                component = dfs(i)\n                components.append(component)\n        \n        return components\n    \n    def _write_binary_stl(self, filename, triangles, normals):\n        """寫入二進制 STL 檔案"""\n        with open(filename, \'wb\') as f:\n            f.write(b\'\\x00\' * 80)\n            f.write(struct.pack(\'I\', len(triangles)))\n            \n            for triangle, normal in zip(triangles, normals):\n                f.write(struct.pack(\'fff\', *normal))\n                for vertex in triangle:\n                    f.write(struct.pack(\'fff\', *vertex))\n                f.write(struct.pack(\'H\', 0))\n\n    def _write_mtl(self, filename, material_name):\n        """寫入 MTL 材質檔案"""\n        with open(filename, \'w\', encoding=\'utf-8\') as f:\n            f.write(f"newmtl {material_name}\\n")\n            f.write("Ka 0.2 0.2 0.2\\n")  # Ambient color\n            f.write("Kd 0.8 0.8 0.8\\n")  # Diffuse color\n            f.write("Ks 0.5 0.5 0.5\\n")  # Specular color\n            f.write("Ns 50.0\\n")         # Specular exponent\n            f.write("d 1.0\\n")           # Transparency (1.0 = opaque)\n            f.write("illum 2\\n")         # Illumination model\n\n    def _write_obj(self, filename, triangles, normals):\n        """寫入 OBJ 檔案"""\n        vertex_dict = {}\n        vertex_list = []\n        normal_list = []\n        faces = []\n        \n        for triangle, normal in zip(triangles, normals):\n            face_indices = []\n            \n            for vertex in triangle:\n                vertex_tuple = tuple(vertex)\n                if vertex_tuple not in vertex_dict:\n                    vertex_dict[vertex_tuple] = len(vertex_list) + 1\n                    vertex_list.append(vertex)\n                face_indices.append(vertex_dict[vertex_tuple])\n            \n            normal_list.append(normal)\n            faces.append(face_indices)\n        \n        # Generate material name from the obj filename\n        material_name = filename.stem\n        # Create MTL filename using Path\n        mtl_filename = filename.with_suffix(\'.mtl\')\n        \n        # Write OBJ file\n        with open(filename, \'w\', encoding=\'utf-8\') as f:\n            # Reference the MTL file\n            f.write(f"mtllib {mtl_filename.name}\\n")\n            f.write(f"usemtl {material_name}\\n\\n")\n            \n            for v in vertex_list:\n                f.write(f"v {v[0]} {v[1]} {v[2]}\\n")\n            \n            for n in normal_list:\n                f.write(f"vn {n[0]} {n[1]} {n[2]}\\n")\n            \n            for i, face in enumerate(faces):\n                f.write(f"f {face[0]}//{i+1} {face[1]}//{i+1} {face[2]}//{i+1}\\n")\n        \n        # Write the corresponding MTL file\n        self._write_mtl(mtl_filename, material_name)\n    \n    def split_and_convert(self):\n        """分割 STL 檔案並轉換為 OBJ 格式"""\n        if self.is_binary:\n            triangles, normals = self._read_binary_stl()\n        else:\n            triangles, normals = self._read_ascii_stl()\n        \n        components = self._split_by_connected_components(triangles, normals)\n        \n        output_dir = Path(\'split_parts\')\n        output_dir.mkdir(exist_ok=True)\n        \n        for i, component in enumerate(components):\n            component_triangles = triangles[component]\n            component_normals = normals[component]\n            \n            base_name = f"part_{i + 1}"\n            stl_filename = output_dir / f"{base_name}.stl"\n            obj_filename = output_dir / f"{base_name}.obj"\n            \n            #self._write_binary_stl(stl_filename, component_triangles, component_normals)\n            self._write_obj(obj_filename, component_triangles, component_normals)\n            \n            print(f"已儲存零件 {i + 1} 到:")\n            #print(f"  STL: {stl_filename}")\n            print(f"  OBJ: {obj_filename}")\n            print(f"  MTL: {obj_filename.with_suffix(\'.mtl\')}")\n        \n        return len(components)\n\n# 直接轉換指定的 STL 檔案\ntry:\n    # 指定要轉換的 STL 檔案名稱和縮放比例\n    stl_file = "win2.stl"\n    scale = 0.01  # 縮放比例，可以根據需要調整 \n \n \n', 'tags': '', 'url': 'w6.html'}, {'title': 'task5', 'text': '', 'tags': '', 'url': 'task5.html'}, {'title': 'w7', 'text': 'solvespace basket_ball_shooter繪製影片: https://youtu.be/Y-5L4rkpk4w \n basket_ball_shooter檔案: /downloads/basketball繪製.zip \n \n', 'tags': '', 'url': 'w7.html'}, {'title': 'w9', 'text': 'shooter導入webot \n \n 過程\xa0 \n 使用老師給的零件圖尺寸，利用 solvespace組裝轉出stl檔，stl檔利用老師的py檔轉成obj供webots使用 \n 打開webots 開起一個robot群組 在robot的children裡建立三個子群組solid當base 兩個hingejoint 一個當joint1檔連桿之間的定位和鎖固，一個當joint4讓連桿的群組和base的另一個軸連接。 \n 在joint1裡建立higejintparameters和solid 在solid裡開啟children建立cadshape用來開啟桿一的外形，再從solid裡開啟mesh開啟桿一的碰撞體積，在開啟phyaixs，開啟桿子的物理性質，讓馬達傳動時會跟著一起運動，在回到joint1的device裡開啟馬達。joint1的higejintparameters是控制joint1軸的位子以及角度，需要特別注意。 \n 後續一直到 joint4都是無限套娃除了馬達不用開其他都一樣，在最後joint4鏈接base的時候要特別注意使用的是solidreference鏈接桿3，要注意的是桿三要取名字。', 'tags': '', 'url': 'w9.html'}, {'title': 'w11', 'text': 'solvespace籃框繪製影片: https://youtu.be/4LJ1-oZEsqI \n 檔案: /downloads/籃框.zip \n \n', 'tags': '', 'url': 'w11.html'}, {'title': 'task6', 'text': 'Webots Tutorial 4 ~6 \n 檔案下載 \n \n', 'tags': '', 'url': 'task6.html'}, {'title': 'Homework', 'text': '', 'tags': '', 'url': 'Homework.html'}, {'title': 'HW1', 'text': '先由solvespace畫簡單的模型模擬旋轉路徑，然後再開始使用Webots進行模型的建立 \n \n \n', 'tags': '', 'url': 'HW1.html'}, {'title': 'HW2', 'text': 'HW2 (5%):  建立由 CAD 繪製零件組成的平面四連桿機構 Webots 模擬場景 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 HW2 - 學員學號 \n \n \n \n \n \n \n \n sovlespace 連桿繪製影片 \n sovlespace 檔案 \n 連桿檔案 \n webot匯入cad檔案影片 \n ---------------------------------------------------- \n 如何將stl轉成obj檔並且拆解 \n 需先在環境中安裝numpy\xa0 \n 在cmd裡打 pip install numpy 即可安裝 \n 然後就可以用.py檔拆stl \n numpy模組介紹 \n 操作影片 \n \n /downloads/split_stl py.7z \xa0拆開的檔案 \n ---------------------------------------------------------------- \n 模擬影片 \n 連桿檔案 /downloads/worlds.7z \n /downloads/fourbar_slvs-2.7z \n \n 連接好的圖片 \n https://youtu.be/ksVo3IAzcmE \xa0詳細製作過程 \n robot的資料夾下children裡有三個檔案 \n solid-1 (基座一) \n solid-2 (基座二) \n hingejoint 連接桿 (中間那三根的特徵) \n 物理性質記得開 不然不會跑\xa0 \n \n', 'tags': '', 'url': 'HW2.html'}, {'title': 'HW3', 'text': 'HW3 (20%): 建立 Webots 桌上籃球遊戲機模擬系統 \n hw3繪製零件 \n /downloads/41223215 shooter.7z \n https://youtu.be/DddqK8xxv5s \xa0半成品模擬影片 \n https://youtu.be/5rvXEyfOqPw \xa0完成品模擬影片 \n https://youtu.be/EJ3XKhpBrUM \xa0webot製作 \n /downloads/shooter-2.7z 檔案 \n \n 過程\xa0 \n sovlespace繪製出零件 繪製出設計圖 再根據設計圖的形狀組配 \n 組配完進行拆解轉檔(obj)(拆解過程會把尺寸縮小0.01倍) \n 進入webot 建robot 建出三個子特徵 solid(base) 兩個hingejoint(一個進行組裝 一個鎖點) \n 組裝過程續注意座標軸(會根據你繪圖起始的地方做原點) 可以進入sovlespace進行測量 \n 測量鎖點點位 過程跟前面四連桿一樣 可以在過程中進行測試 看看點位有沒有準 \n 鎖好之後模擬(我有發現老師給的設計圖因為角度會讓球沒辦法射那麼遠 所以我自己改良了程式 在發射前程式會先畜力) \n 加入球體(shape) 給定物理性質 \n 加入地板(floor)\xa0 \n 加入籃框(我在畫籃框時 匯入webot有個問題 因為沒有轉檔(沒必要)所以尺寸是正常的100倍 所以我自己又改了老師的分解檔案 去掉拆開的部分 只保留鎖小跟轉檔的能力) \n 之後模擬就成功了\xa0 \n 以下為鎖小功能py檔 \n #!/usr/bin/env python\n# -*- coding: utf-8 -*-\n"""\nSTL to OBJ converter with scaling support\n"""\n\nimport struct\nimport numpy as np\nfrom pathlib import Path\n\nclass STLConverter:\n    def __init__(self, filename, scale=0.001):\n        self.filename = filename\n        self.scale = scale\n        self.is_binary = self._check_if_binary()\n        \n    def _check_if_binary(self):\n        with open(self.filename, \'rb\') as f:\n            header = f.read(5).decode(\'utf-8\', errors=\'ignore\')\n            return not header.startswith(\'solid\')\n    \n    def _read_binary_stl(self):\n        with open(self.filename, \'rb\') as f:\n            f.seek(80)\n            triangle_count = struct.unpack(\'I\', f.read(4))[0]\n            \n            triangles = []\n            normals = []\n            \n            for _ in range(triangle_count):\n                nx, ny, nz = struct.unpack(\'fff\', f.read(12))\n                normals.append([nx, ny, nz])\n                \n                triangle = []\n                for _ in range(3):\n                    x, y, z = struct.unpack(\'fff\', f.read(12))\n                    triangle.append([x * self.scale, y * self.scale, z * self.scale])\n                triangles.append(triangle)\n                \n                f.seek(2, 1)\n                \n        return np.array(triangles), np.array(normals)\n    \n    def _read_ascii_stl(self):\n        triangles = []\n        normals = []\n        current_triangle = []\n        \n        with open(self.filename, \'r\') as f:\n            for line in f:\n                line = line.strip()\n                if not line:\n                    continue\n                    \n                parts = line.split()\n                if not parts:\n                    continue\n                \n                if parts[0] == \'facet\' and parts[1] == \'normal\':\n                    normals.append([float(parts[2]), float(parts[3]), float(parts[4])])\n                elif parts[0] == \'vertex\':\n                    current_triangle.append([\n                        float(parts[1]) * self.scale,\n                        float(parts[2]) * self.scale,\n                        float(parts[3]) * self.scale\n                    ])\n                elif parts[0] == \'endfacet\':\n                    if current_triangle:\n                        triangles.append(current_triangle)\n                        current_triangle = []\n        \n        return np.array(triangles), np.array(normals)\n\n    def _write_mtl(self, filename, material_name):\n        with open(filename, \'w\', encoding=\'utf-8\') as f:\n            f.write(f"newmtl {material_name}\\n")\n            f.write("Ka 0.2 0.2 0.2\\n")\n            f.write("Kd 0.8 0.8 0.8\\n")\n            f.write("Ks 0.5 0.5 0.5\\n")\n            f.write("Ns 50.0\\n")\n            f.write("d 1.0\\n")\n            f.write("illum 2\\n")\n\n    def _write_obj(self, filename, triangles, normals):\n        vertex_dict = {}\n        vertex_list = []\n        normal_list = []\n        faces = []\n        \n        for triangle, normal in zip(triangles, normals):\n            face_indices = []\n            \n            for vertex in triangle:\n                vertex_tuple = tuple(vertex)\n                if vertex_tuple not in vertex_dict:\n                    vertex_dict[vertex_tuple] = len(vertex_list) + 1\n                    vertex_list.append(vertex)\n                face_indices.append(vertex_dict[vertex_tuple])\n            \n            normal_list.append(normal)\n            faces.append(face_indices)\n        \n        material_name = filename.stem\n        mtl_filename = filename.with_suffix(\'.mtl\')\n        \n        with open(filename, \'w\', encoding=\'utf-8\') as f:\n            f.write(f"mtllib {mtl_filename.name}\\n")\n            f.write(f"usemtl {material_name}\\n\\n")\n            \n            for v in vertex_list:\n                f.write(f"v {v[0]} {v[1]} {v[2]}\\n")\n            \n            for n in normal_list:\n                f.write(f"vn {n[0]} {n[1]} {n[2]}\\n")\n            \n            for i, face in enumerate(faces):\n                f.write(f"f {face[0]}//{i+1} {face[1]}//{i+1} {face[2]}//{i+1}\\n")\n        \n        self._write_mtl(mtl_filename, material_name)\n    \n    def convert(self, output_path):\n        if self.is_binary:\n            triangles, normals = self._read_binary_stl()\n        else:\n            triangles, normals = self._read_ascii_stl()\n        \n        output_path = Path(output_path)\n        output_path.parent.mkdir(parents=True, exist_ok=True)\n        self._write_obj(output_path, triangles, normals)\n        print(f"轉換完成：{output_path}")\n        print(f"材質檔：{output_path.with_suffix(\'.mtl\')}")\n\n# 使用範例\ntry:\n    input_stl = "籃框.stl"\n    output_obj = "output/籃框.obj"\n    scale = 0.005\n\n    converter = STLConverter(input_stl, scale=scale)\n    converter.convert(output_obj)\nexcept Exception as e:\n    print(f"錯誤: {e}")\n \n \n 以下為畜力控制器 \n from controller import Robot\nimport time\n\ndef run_robot():\n    # Create the Robot instance\n    robot = Robot()\n\n    # Get simulation time step\n    timestep = int(robot.getBasicTimeStep())\n\n    # Get motor and keyboard devices\n    motor = robot.getDevice(\'motor1\')\n    keyboard = robot.getKeyboard()\n    keyboard.enable(timestep)\n\n    # Convert degrees to radians\n    def deg2rad(deg):\n        return deg * 3.14159 / 180\n\n    # Set initial motor position to -5 degrees (蓄力)\n    motor.setPosition(deg2rad(-10))\n    # Wait for a short time (e.g., 1 second) to complete the back movement\n    for _ in range(int(300 / timestep)):  # wait ~1 second\n        if robot.step(timestep) == -1:\n            return\n\n    # Main control loop\n    while robot.step(timestep) != -1:\n        # Move to 38 degrees\n        motor.setPosition(deg2rad(38))\n\nif __name__ == "__main__":\n    run_robot()\n \n \n', 'tags': '', 'url': 'HW3.html'}, {'title': 'Exam', 'text': '', 'tags': '', 'url': 'Exam.html'}, {'title': 'Exam1', 'text': 'Exam1 (10%): 建立 Webots 基本物件模擬場景 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam1 - 學員學號 \n 繪製連桿 \n \n 連桿距離 \n \n 運轉 \n 運轉壓縮檔 :\xa0 /downloads/Exam1運轉.zip \n \n', 'tags': '', 'url': 'Exam1.html'}, {'title': 'Exam2', 'text': 'Exam2 (10%): 利用 CAD 零組件建立模擬場景 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam2 - 41223226 \n Exam2 \n \n', 'tags': '', 'url': 'Exam2.html'}, {'title': 'Exam3', 'text': 'Exam3 (20%): Webots 機電模擬場景的協同設計 \n 操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam3 - 學員學號 \n 以下為exam3-1製作過程: \n 首先收尋到控制室>網路和網際網路>網路和共用中心的檢視網路狀態及工作>找到乙太網路>內容>找到IPv6> \n 以我的為範例 我的地址和dns為 ( IPv6地址是到 老師網站 找 ) \n 2001:288:6004:17:fff1:cd25:0000:b047 \n 修好後打開cmd\xa0 輸入webotsw --stream "你的HW1的wbt檔案位置" \n webotsw下面有序號1234對應到網址上數字 \n 打開後http://localhost:1234/index.html可以看到模擬程式 \n 這是我的 Connect to: ws://[2001:288:6004:17:fff1:cd25:0000:b047]:1234 \n 如果是要組員查看的話 改成組員的ipv6地址 \n \n \n 以下為exam3-2 製作過程: \n 首先先下載老師的七段顯示器進行修改,利用GPT了解程式碼功能,可在number = 235 更改數值,後面過程和exam3-1一樣瀏覽器檢視 \n \n \n 以下為exam3-3 製作過程: \n 這裡也是一樣用上面的方式開啟程式,利用老師給的.wbt來模擬,並到瀏覽器檢視 \n \n', 'tags': '', 'url': 'Exam3.html'}, {'title': 'Final', 'text': '期末協同專案執行過程影片、簡報與 PDf 報告檔案 (六人一組) (30%) \n 題目:  Webots 動態投籃模擬系統的協同設計 \n 說明:  \n 籃框架被配置在一定範圍內, 可隨機慢速前進、後退及左右擺動, 投籃機構系統帶有一定數量的籃球, 被配置在可自由移動的輪車上. \n 操作者可利用鍵盤特定按鍵控制投籃輪車的移動並發射投籃, 每投出一球後系統透過記分板進行計分, 並由送球機構進行補球或移動輪車取球, 遊戲可進行至全部數量籃球投完為止. \n 請將期末協同專案執行過程、內容與心得, 製作成影片，配合字幕上傳至 Youtube 後嵌入各階段的期末報告頁面中. \n 影片標題:  國立虎尾科技大學 - 機械設計工程系 - cd2025 期末報告 - 學員學號 - 各階段影片主題 \n \n /downloads/final project.7z \xa0檔案位置 \n https://youtu.be/5besxJuk2bs \xa0模擬影片-1 把shooter和車子黏起來 利用bounding object group來實現 \n 以下是控制車子和投射器的程式檔案 \n from controller import Robot, Keyboard\nimport time\n\n# Constants\nTIME_STEP = 32\nMAX_VELOCITY = 10.0\nANGLE_STEP = 40 * 3.14159 / 180  # 40 degrees in radians\nPOSITION_M = ANGLE_STEP          # +40 deg (擊出)\nPOSITION_K = 0.0                 # 0 deg  (收回)\nKICK_DELAY = 0.5                 # 擊出後延遲時間 (秒)\n\n# Initialize robot and keyboard\nrobot = Robot()\ntimestep = int(robot.getBasicTimeStep())\nkeyboard = Keyboard()\nkeyboard.enable(timestep)\n\n# Get motor and sensor\ntry:\n    motor = robot.getDevice(\'motor1\')\n    sensor = robot.getDevice(\'motor1_sensor\')\n    sensor.enable(timestep)\n    mechanism_enabled = True\nexcept Exception:\n    mechanism_enabled = False\n\n# Get wheels\ntry:\n    wheels = [robot.getDevice(f"wheel{i+1}") for i in range(4)]\n    for wheel in wheels:\n        wheel.setPosition(float(\'inf\'))  # Infinite position for velocity control\n        wheel.setVelocity(0)\n    platform_enabled = True\nexcept Exception:\n    platform_enabled = False\n\n# Debounce key\nkey_pressed = {\n    \'k\': False\n}\n\nwhile robot.step(timestep) != -1:\n    key = keyboard.getKey()\n\n    # Platform control\n    if platform_enabled:\n        if key == Keyboard.UP:\n            for wheel in wheels:\n                wheel.setVelocity(MAX_VELOCITY)\n        elif key == Keyboard.DOWN:\n            for wheel in wheels:\n                wheel.setVelocity(-MAX_VELOCITY)\n        elif key == Keyboard.LEFT:\n            wheels[0].setVelocity(MAX_VELOCITY)\n            wheels[1].setVelocity(-MAX_VELOCITY)\n            wheels[2].setVelocity(MAX_VELOCITY)\n            wheels[3].setVelocity(-MAX_VELOCITY)\n        elif key == Keyboard.RIGHT:\n            wheels[0].setVelocity(-MAX_VELOCITY)\n            wheels[1].setVelocity(MAX_VELOCITY)\n            wheels[2].setVelocity(-MAX_VELOCITY)\n            wheels[3].setVelocity(MAX_VELOCITY)\n        elif key == ord(\'Q\') or key == ord(\'q\'):\n            print("Exiting...")\n            break\n        else:\n            for wheel in wheels:\n                wheel.setVelocity(0)\n\n    # Kick mechanism control\n    if mechanism_enabled:\n        if key == ord(\'M\') or key == ord(\'k\'):\n            if not key_pressed[\'M\']:\n                print("[KICK] 出擊 → 收回")\n                motor.setPosition(POSITION_M)\n                \n                # 延遲（非阻塞式等待）\n                start_time = robot.getTime()\n                while robot.step(timestep) != -1:\n                    if robot.getTime() - start_time >= KICK_DELAY:\n                        break\n\n                motor.setPosition(POSITION_K)\n            key_pressed[\'M\'] = True\n        else:\n            key_pressed[\'M\'] = False\n \n \n /downloads/final project (2).7z \xa0這是加上補球的檔案 \n https://youtu.be/GoxnCxqUoD8 \xa0這是製作過程 \n https://youtu.be/A2Gu5H4j0zk \xa0 這是展示影片 \n \n 製作具體流程 先創立一個新的robot 把supervisor改成true 令我們可以用程式創建球體 \n 之後匯入.py檔案 就可以開始了 \n 以下是控制發球機構的程式 \n from controller import Supervisor, Keyboard\nimport time\nimport random\nimport numpy as np\nimport re\n\n# ----------------- 參數區 -----------------\nHOOP_CENTER = [0.622, -0.103, 0.742838]\nBALL_DEF_PATTERN = re.compile(r"Sphere_\\d+")\nsupervisor = Supervisor()\ntimestep = int(supervisor.getBasicTimeStep())\nkeyboard = Keyboard()\nkeyboard.enable(timestep)\n\nsphere_radius = 0.1\nTRAJECTORY_POINT_RADIUS = 0.03      # 軌跡小球半徑\nTRAJECTORY_POINT_STEP = 0.12        # 軌跡點間最小距離\nTRAJECTORY_MAX_POINTS = 5           # 只保留5個軌跡點\n\nwaiting_ball_def = None\nwaiting_ball_info = None\nlast_key_time = 0\ndebounce_time = 0.5\ndefault_feed_pos = (0.029277, 0.020116, 1.37973)\nPRINT_INTERVAL = 0.2\n\ncurrent_tracked_def = None\nlast_print_time = time.time()\n\n# 軌跡資料\ntrajectory_points = []  # [(pos, def_name)] 最多五個\n\ndef axis_angle_to_rotation_matrix(axis, angle):\n    x, y, z = axis\n    c = np.cos(angle)\n    s = np.sin(angle)\n    C = 1 - c\n    return np.array([\n        [x*x*C + c,   x*y*C - z*s, x*z*C + y*s],\n        [y*x*C + z*s, y*y*C + c,   y*z*C - x*s],\n        [z*x*C - y*s, z*y*C + x*s, z*z*C + c]\n    ])\n\ndef generate_valid_def_name(base_name="Sphere"):\n    timestamp = int(supervisor.getTime() * 1000)\n    return f"{base_name}_{timestamp}_{random.randint(0, 10000)}"\n\ndef generate_random_color():\n    return random.random(), random.random(), random.random()\n\ndef youbot_local_to_world(local_pos):\n    youbot_node = supervisor.getFromDef(\'youbot\')\n    if youbot_node is None:\n        raise RuntimeError("找不到 DEF 為 youbot 的 Robot 物件")\n    youbot_translation = np.array(youbot_node.getField(\'translation\').getSFVec3f())\n    youbot_rotation = youbot_node.getField(\'rotation\').getSFRotation()\n    youbot_axis = youbot_rotation[:3]\n    youbot_angle = youbot_rotation[3]\n    youbot_rot_mat = axis_angle_to_rotation_matrix(youbot_axis, youbot_angle)\n    rotated = youbot_rot_mat @ np.array(local_pos)\n    world_pos = youbot_translation + rotated\n    return tuple(world_pos)\n\ndef create_static_ball(def_name, world_pos, r, g, b):\n    sphere_string = f"""\n    DEF {def_name} Solid {{\n      translation {world_pos[0]} {world_pos[1]} {world_pos[2]}\n      contactMaterial "ball"\n      children [\n        Shape {{\n          geometry Sphere {{\n            radius {sphere_radius}\n          }}\n          appearance Appearance {{\n            material Material {{\n              diffuseColor {r} {g} {b}\n            }}\n          }}\n        }}\n      ]\n      boundingObject Sphere {{\n        radius {sphere_radius}\n      }}\n    }}\n    """\n    root = supervisor.getRoot()\n    children_field = root.getField("children")\n    children_field.importMFNodeFromString(-1, sphere_string)\n\ndef create_dynamic_ball(def_name, world_pos, r, g, b):\n    sphere_string = f"""\n    DEF {def_name} Solid {{\n      translation {world_pos[0]} {world_pos[1]} {world_pos[2]}\n      contactMaterial "ball"\n      children [\n        Shape {{\n          geometry Sphere {{\n            radius {sphere_radius}\n          }}\n          appearance Appearance {{\n            material Material {{\n              diffuseColor {r} {g} {b}\n            }}\n          }}\n        }}\n      ]\n      boundingObject Sphere {{\n        radius {sphere_radius}\n      }}\n      physics Physics {{\n        mass 0.01\n        density -1\n      }}\n    }}\n    """\n    root = supervisor.getRoot()\n    children_field = root.getField("children")\n    children_field.importMFNodeFromString(-1, sphere_string)\n\ndef create_trajectory_point(pos):\n    """\n    在pos位置新增一個小球作為拋物線軌跡點，回傳DEF名稱。\n    用Transform持有Shape，僅作視覺標記，不影響物理。\n    """\n    def_name = generate_valid_def_name("TrajectoryPt")\n    sphere_string = f"""\n    DEF {def_name} Transform {{\n      translation {pos[0]} {pos[1]} {pos[2]}\n      children [\n        Shape {{\n          geometry Sphere {{\n            radius {TRAJECTORY_POINT_RADIUS}\n          }}\n          appearance Appearance {{\n            material Material {{\n              diffuseColor 1 0.7 0\n              transparency 0.3\n            }}\n          }}\n        }}\n      ]\n    }}\n    """\n    root = supervisor.getRoot()\n    children_field = root.getField("children")\n    children_field.importMFNodeFromString(-1, sphere_string)\n    return def_name\n\ndef delete_trajectory_points():\n    """刪除所有軌跡點"""\n    global trajectory_points\n    for _, def_name in trajectory_points:\n        node = supervisor.getFromDef(def_name)\n        if node:\n            node.remove()\n    trajectory_points.clear()\n\ndef create_static_sphere(supervisor, x, y, z):\n    global waiting_ball_def, waiting_ball_info\n    def_name = generate_valid_def_name()\n    waiting_ball_def = def_name\n    r, g, b = generate_random_color()\n    world_pos = youbot_local_to_world((x, y, z))\n    waiting_ball_info = (world_pos, r, g, b)\n    create_static_ball(def_name, world_pos, r, g, b)\n\ndef activate_dynamic_ball():\n    global waiting_ball_def, waiting_ball_info\n    if waiting_ball_def is None or waiting_ball_info is None:\n        return\n    ball_node = supervisor.getFromDef(waiting_ball_def)\n    if ball_node is not None:\n        ball_node.remove()\n        supervisor.step(int(supervisor.getBasicTimeStep()))\n    world_pos, r, g, b = waiting_ball_info\n    create_dynamic_ball(waiting_ball_def, world_pos, r, g, b)\n    waiting_ball_def = None\n    waiting_ball_info = None\n\ndef is_ball_landed(pos, threshold_z=0.13):\n    """當球z接近地面時視為落地"""\n    return pos[2] < threshold_z\n\nprint("按 A 產生一顆靜止球，按 M 讓球變 dynamic 可擊出（最多只有5個軌跡點跟著球跑，球落地後軌跡自動消失）")\n\nwhile supervisor.step(timestep) != -1:\n    key = keyboard.getKey()\n    current_time = time.time()\n    # 產生球\n    if key == ord(\'A\') and (current_time - last_key_time >= debounce_time):\n        if waiting_ball_def is None:\n            create_static_sphere(supervisor, *default_feed_pos)\n            current_tracked_def = waiting_ball_def\n            delete_trajectory_points()  # 新球產生時清除舊軌跡\n        else:\n            print("還有一顆球等待擊出，請先擊出再產生新球。")\n        last_key_time = current_time\n    # 讓球變動態\n    if key == ord(\'M\') and (current_time - last_key_time >= debounce_time):\n        activate_dynamic_ball()\n        last_key_time = current_time\n\n    # 拋物線軌跡追蹤\n    if current_tracked_def is not None:\n        ball_node = supervisor.getFromDef(current_tracked_def)\n        if ball_node is not None:\n            pos = ball_node.getPosition()\n            # 每 PRINT_INTERVAL 印座標\n            if current_time - last_print_time >= PRINT_INTERVAL:\n                #print(f"球 {current_tracked_def} 絕對座標: [{pos[0]:.4f}, {pos[1]:.4f}, {pos[2]:.4f}]")\n                last_print_time = current_time\n            # 軌跡點：每隔一段距離才加一個，僅保留5個點\n            if (not trajectory_points) or np.linalg.norm(np.array(pos) - np.array(trajectory_points[-1][0])) > TRAJECTORY_POINT_STEP:\n                def_name = create_trajectory_point(pos)\n                trajectory_points.append((pos, def_name))\n                if len(trajectory_points) > TRAJECTORY_MAX_POINTS:\n                    # 移除最舊的點\n                    _, old_def = trajectory_points.pop(0)\n                    node = supervisor.getFromDef(old_def)\n                    if node:\n                        node.remove()\n            # 若球落地，自動清除軌跡\n            if is_ball_landed(pos):\n                delete_trajectory_points()\n        else:\n            # 球消失，停止追蹤並清除軌跡\n            delete_trajectory_points()\n            current_tracked_def = None\n# Enter here exit cleanup code.\n \n https://youtu.be/f6KmEgIFJbw \xa0模擬影片 \n /downloads/final project (3).7z \xa0這是檔案(第三版) \n 以下是籃框的移動和偵測系統 \n from controller import Robot, Keyboard, Emitter\n\n# Constants\nWHEEL_RADIUS = 0.1  # Radius of the wheels in meters\nL = 0.471  # Half of the robot\'s length\nW = 0.376  # Half of the robot\'s width\nMAX_VELOCITY = 10.0  # Maximum wheel velocity\n\n# Initialize robot and keyboard\nrobot = Robot()\ntimestep = int(robot.getBasicTimeStep())\nkeyboard = Keyboard()\nkeyboard.enable(timestep)\n\n# Get emitter device for sending score\nemitter = robot.getDevice("score_emitter")\n\n# Get distance sensor\nsensor = robot.getDevice(\'sensor\')\nsensor.enable(timestep)\nscore = 0\nlast_score_time = 0\ncooldown = 1.0\n\n# Get motors\nwheel5 = robot.getDevice("wheel5")  # Front-right\nwheel6 = robot.getDevice("wheel6")  # Front-left\nwheel7 = robot.getDevice("wheel7")  # Rear-right\nwheel8 = robot.getDevice("wheel8")  # Rear-left\n\n# Enable velocity control\nfor wheel in [wheel5, wheel6, wheel7, wheel8]:\n    wheel.setPosition(float(\'inf\'))\n    wheel.setVelocity(0)\n\ndef set_wheel_velocity(v1, v2, v3, v4):\n    wheel5.setVelocity(v1)\n    wheel6.setVelocity(v2)\n    wheel7.setVelocity(v3)\n    wheel8.setVelocity(v4)\n\n# Lookup table for AD to distance\nlookup_table = [\n    (1000, 0.00),\n    (620, 0.12),\n    (372, 0.13),\n    (248, 0.14),\n    (186, 0.15),\n    (0, 0.18)\n]\n\ndef ad_to_distance(ad_value):\n    for i in range(len(lookup_table) - 1):\n        a0, d0 = lookup_table[i]\n        a1, d1 = lookup_table[i + 1]\n        if a1 <= ad_value <= a0:\n            return d0 + (d1 - d0) * (ad_value - a0) / (a1 - a0)\n    if ad_value > lookup_table[0][0]:\n        return lookup_table[0][1]\n    return lookup_table[-1][1]\n\n# User instructions\nprint("Controls:")\nprint("U = forward, J = backward, H = turn left, K = turn right, Q = quit")\n\n# Main loop\nkeys = set()\nwhile robot.step(timestep) != -1:\n    key = keyboard.getKey()\n    while key != -1:\n        keys.add(key)\n        key = keyboard.getKey()\n\n    sensor_value = sensor.getValue()\n    distance = ad_to_distance(sensor_value)\n    current_time = robot.getTime()\n\n    if ord(\'M\') in keys or ord(\'m\') in keys:\n        print("Distance (M):", distance)\n    if ord(\'K\') in keys or ord(\'k\') in keys:\n        print("Distance (K):", distance)\n\n    if distance < 0.18 and (current_time - last_score_time) > cooldown:\n        score += 2\n        last_score_time = current_time\n        print("得分 +2")\n        print("Current Distance:", distance)\n        emitter.send(str(2))  # 送出得分\n\n    # Movement control\n    if ord(\'U\') in keys or ord(\'u\') in keys:\n        set_wheel_velocity(MAX_VELOCITY, MAX_VELOCITY, MAX_VELOCITY, MAX_VELOCITY)\n    elif ord(\'J\') in keys or ord(\'j\') in keys:\n        set_wheel_velocity(-MAX_VELOCITY, -MAX_VELOCITY, -MAX_VELOCITY, -MAX_VELOCITY)\n    elif ord(\'K\') in keys or ord(\'k\') in keys:\n        set_wheel_velocity(-MAX_VELOCITY, MAX_VELOCITY, -MAX_VELOCITY, MAX_VELOCITY)\n    elif ord(\'H\') in keys or ord(\'h\') in keys:\n        set_wheel_velocity(MAX_VELOCITY, -MAX_VELOCITY, MAX_VELOCITY, -MAX_VELOCITY)\n    elif ord(\'Q\') in keys or ord(\'q\') in keys:\n        print("Exiting...")\n        break\n    else:\n        set_wheel_velocity(0, 0, 0, 0)\n\n    keys.clear()\n \n 以下是七段顯示器的控制系統 \n from controller import Supervisor \n SEGMENTS = [  [1,1,1,1,1,1,0], # 0  [0,1,1,0,0,0,0], # 1  [1,1,0,1,1,0,1], # 2  [1,1,1,1,0,0,1], # 3  [0,1,1,0,0,1,1], # 4  [1,0,1,1,0,1,1], # 5  [1,0,1,1,1,1,1], # 6  [1,1,1,0,0,0,0], # 7  [1,1,1,1,1,1,1], # 8  [1,1,1,1,0,1,1], # 9 ] DIGIT_MATERIALS = [  [\'a3mat\', \'b3mat\', \'c3mat\', \'d3mat\', \'e3mat\', \'f3mat\', \'g3mat\'], # 百  [\'a2mat\', \'b2mat\', \'c2mat\', \'d2mat\', \'e2mat\', \'f2mat\', \'g2mat\'], # 十  [\'a1mat\', \'b1mat\', \'c1mat\', \'d1mat\', \'e1mat\', \'f1mat\', \'g1mat\'], # 個 ] ON_COLOR = [0, 1, 0] OFF_COLOR = [0.05, 0.05, 0.05] \n def set_digit(supervisor, digit_index, value):  segs = SEGMENTS[value]  for i, seg_on in enumerate(segs):  mat_node = supervisor.getFromDef(DIGIT_MATERIALS[digit_index][i])  if mat_node:  mat_node.getField(\'diffuseColor\').setSFColor(ON_COLOR if seg_on else OFF_COLOR)  else:  print(f"找不到 {DIGIT_MATERIALS[digit_index][i]} 這個DEF") \n def set_display(supervisor, value):  value = max(0, min(999, int(value)))  h = value // 100  t = (value // 10) % 10  u = value % 10  set_digit(supervisor, 0, h)  set_digit(supervisor, 1, t)  set_digit(supervisor, 2, u) \n supervisor = Supervisor() timestep = int(supervisor.getBasicTimeStep()) \n score = 0 receiver = supervisor.getDevice("score_receiver") receiver.enable(timestep) \n while supervisor.step(timestep) != -1:  while receiver.getQueueLength() > 0:  data = receiver.getString()  if data.isdigit():  try:  received_score = int(data)  score += received_score  print(f"收到得分訊息: +{received_score}, 總分: {score}")  except Exception as e:  print("訊息格式錯誤:", e)  receiver.nextPacket()  set_display(supervisor, score) \n /downloads/final project (4).7z \xa0以下是檔案位置 \n https://youtu.be/_fwgpqRz49E \xa0這是模擬影片 \n https://youtu.be/RgQjZCgOqFg \xa0這是製作過程 \n \n', 'tags': '', 'url': 'Final.html'}, {'title': 'Brython', 'text': '1 add to 100 \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n \n', 'tags': '', 'url': 'Brython.html'}]};